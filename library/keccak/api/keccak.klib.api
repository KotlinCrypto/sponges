// Klib ABI Dump
// Targets: [androidNativeArm32, androidNativeArm64, androidNativeX64, androidNativeX86, iosArm64, iosSimulatorArm64, iosX64, js, linuxArm64, linuxX64, macosArm64, macosX64, mingwX64, tvosArm64, tvosSimulatorArm64, tvosX64, wasmJs, wasmWasi, watchosArm32, watchosArm64, watchosDeviceArm64, watchosSimulatorArm64, watchosX64]
// Rendering settings:
// - Signature version: 2
// - Show manifest properties: true
// - Show declarations: true

// Library unique name: <org.kotlincrypto.sponges:keccak>
final class org.kotlincrypto.sponges.keccak/F1600 : org.kotlincrypto.sponges.keccak/State<kotlin/Long, org.kotlincrypto.sponges.keccak/F1600> { // org.kotlincrypto.sponges.keccak/F1600|null[0]
    constructor <init>() // org.kotlincrypto.sponges.keccak/F1600.<init>|<init>(){}[0]

    final fun addData(kotlin/Int, kotlin/Long) // org.kotlincrypto.sponges.keccak/F1600.addData|addData(kotlin.Int;kotlin.Long){}[0]
    final fun contains(kotlin/Long): kotlin/Boolean // org.kotlincrypto.sponges.keccak/F1600.contains|contains(kotlin.Long){}[0]
    final fun containsAll(kotlin.collections/Collection<kotlin/Long>): kotlin/Boolean // org.kotlincrypto.sponges.keccak/F1600.containsAll|containsAll(kotlin.collections.Collection<kotlin.Long>){}[0]
    final fun copy(): org.kotlincrypto.sponges.keccak/F1600 // org.kotlincrypto.sponges.keccak/F1600.copy|copy(){}[0]
    final fun get(kotlin/Int): kotlin/Long // org.kotlincrypto.sponges.keccak/F1600.get|get(kotlin.Int){}[0]
    final fun iterator(): kotlin.collections/Iterator<kotlin/Long> // org.kotlincrypto.sponges.keccak/F1600.iterator|iterator(){}[0]
    final fun reset() // org.kotlincrypto.sponges.keccak/F1600.reset|reset(){}[0]
}

final class org.kotlincrypto.sponges.keccak/F200 : org.kotlincrypto.sponges.keccak/State<kotlin/Byte, org.kotlincrypto.sponges.keccak/F200> { // org.kotlincrypto.sponges.keccak/F200|null[0]
    constructor <init>() // org.kotlincrypto.sponges.keccak/F200.<init>|<init>(){}[0]

    final fun addData(kotlin/Int, kotlin/Byte) // org.kotlincrypto.sponges.keccak/F200.addData|addData(kotlin.Int;kotlin.Byte){}[0]
    final fun contains(kotlin/Byte): kotlin/Boolean // org.kotlincrypto.sponges.keccak/F200.contains|contains(kotlin.Byte){}[0]
    final fun containsAll(kotlin.collections/Collection<kotlin/Byte>): kotlin/Boolean // org.kotlincrypto.sponges.keccak/F200.containsAll|containsAll(kotlin.collections.Collection<kotlin.Byte>){}[0]
    final fun copy(): org.kotlincrypto.sponges.keccak/F200 // org.kotlincrypto.sponges.keccak/F200.copy|copy(){}[0]
    final fun get(kotlin/Int): kotlin/Byte // org.kotlincrypto.sponges.keccak/F200.get|get(kotlin.Int){}[0]
    final fun iterator(): kotlin.collections/Iterator<kotlin/Byte> // org.kotlincrypto.sponges.keccak/F200.iterator|iterator(){}[0]
    final fun reset() // org.kotlincrypto.sponges.keccak/F200.reset|reset(){}[0]
}

final class org.kotlincrypto.sponges.keccak/F400 : org.kotlincrypto.sponges.keccak/State<kotlin/Short, org.kotlincrypto.sponges.keccak/F400> { // org.kotlincrypto.sponges.keccak/F400|null[0]
    constructor <init>() // org.kotlincrypto.sponges.keccak/F400.<init>|<init>(){}[0]

    final fun addData(kotlin/Int, kotlin/Short) // org.kotlincrypto.sponges.keccak/F400.addData|addData(kotlin.Int;kotlin.Short){}[0]
    final fun contains(kotlin/Short): kotlin/Boolean // org.kotlincrypto.sponges.keccak/F400.contains|contains(kotlin.Short){}[0]
    final fun containsAll(kotlin.collections/Collection<kotlin/Short>): kotlin/Boolean // org.kotlincrypto.sponges.keccak/F400.containsAll|containsAll(kotlin.collections.Collection<kotlin.Short>){}[0]
    final fun copy(): org.kotlincrypto.sponges.keccak/F400 // org.kotlincrypto.sponges.keccak/F400.copy|copy(){}[0]
    final fun get(kotlin/Int): kotlin/Short // org.kotlincrypto.sponges.keccak/F400.get|get(kotlin.Int){}[0]
    final fun iterator(): kotlin.collections/Iterator<kotlin/Short> // org.kotlincrypto.sponges.keccak/F400.iterator|iterator(){}[0]
    final fun reset() // org.kotlincrypto.sponges.keccak/F400.reset|reset(){}[0]
}

final class org.kotlincrypto.sponges.keccak/F800 : org.kotlincrypto.sponges.keccak/State<kotlin/Int, org.kotlincrypto.sponges.keccak/F800> { // org.kotlincrypto.sponges.keccak/F800|null[0]
    constructor <init>() // org.kotlincrypto.sponges.keccak/F800.<init>|<init>(){}[0]

    final fun addData(kotlin/Int, kotlin/Int) // org.kotlincrypto.sponges.keccak/F800.addData|addData(kotlin.Int;kotlin.Int){}[0]
    final fun contains(kotlin/Int): kotlin/Boolean // org.kotlincrypto.sponges.keccak/F800.contains|contains(kotlin.Int){}[0]
    final fun containsAll(kotlin.collections/Collection<kotlin/Int>): kotlin/Boolean // org.kotlincrypto.sponges.keccak/F800.containsAll|containsAll(kotlin.collections.Collection<kotlin.Int>){}[0]
    final fun copy(): org.kotlincrypto.sponges.keccak/F800 // org.kotlincrypto.sponges.keccak/F800.copy|copy(){}[0]
    final fun get(kotlin/Int): kotlin/Int // org.kotlincrypto.sponges.keccak/F800.get|get(kotlin.Int){}[0]
    final fun iterator(): kotlin.collections/Iterator<kotlin/Int> // org.kotlincrypto.sponges.keccak/F800.iterator|iterator(){}[0]
    final fun reset() // org.kotlincrypto.sponges.keccak/F800.reset|reset(){}[0]
}

sealed class <#A: kotlin/Number, #B: org.kotlincrypto.sponges.keccak/State<#A, #B>> org.kotlincrypto.sponges.keccak/State : kotlin.collections/Collection<#A> { // org.kotlincrypto.sponges.keccak/State|null[0]
    constructor <init>(kotlin/Byte) // org.kotlincrypto.sponges.keccak/State.<init>|<init>(kotlin.Byte){}[0]

    final val roundCount // org.kotlincrypto.sponges.keccak/State.roundCount|{}roundCount[0]
        final fun <get-roundCount>(): kotlin/Byte // org.kotlincrypto.sponges.keccak/State.roundCount.<get-roundCount>|<get-roundCount>(){}[0]
    final val size // org.kotlincrypto.sponges.keccak/State.size|{}size[0]
        final fun <get-size>(): kotlin/Int // org.kotlincrypto.sponges.keccak/State.size.<get-size>|<get-size>(){}[0]

    abstract fun addData(kotlin/Int, #A) // org.kotlincrypto.sponges.keccak/State.addData|addData(kotlin.Int;1:0){}[0]
    abstract fun copy(): #B // org.kotlincrypto.sponges.keccak/State.copy|copy(){}[0]
    abstract fun get(kotlin/Int): #A // org.kotlincrypto.sponges.keccak/State.get|get(kotlin.Int){}[0]
    abstract fun reset() // org.kotlincrypto.sponges.keccak/State.reset|reset(){}[0]
    final fun isEmpty(): kotlin/Boolean // org.kotlincrypto.sponges.keccak/State.isEmpty|isEmpty(){}[0]

    final object Companion // org.kotlincrypto.sponges.keccak/State.Companion|null[0]
}

final fun (org.kotlincrypto.sponges.keccak/F1600).org.kotlincrypto.sponges.keccak/keccakP(kotlin/Byte =...) // org.kotlincrypto.sponges.keccak/keccakP|keccakP@org.kotlincrypto.sponges.keccak.F1600(kotlin.Byte){}[0]
final fun (org.kotlincrypto.sponges.keccak/F200).org.kotlincrypto.sponges.keccak/keccakP(kotlin/Byte =...) // org.kotlincrypto.sponges.keccak/keccakP|keccakP@org.kotlincrypto.sponges.keccak.F200(kotlin.Byte){}[0]
final fun (org.kotlincrypto.sponges.keccak/F400).org.kotlincrypto.sponges.keccak/keccakP(kotlin/Byte =...) // org.kotlincrypto.sponges.keccak/keccakP|keccakP@org.kotlincrypto.sponges.keccak.F400(kotlin.Byte){}[0]
final fun (org.kotlincrypto.sponges.keccak/F800).org.kotlincrypto.sponges.keccak/keccakP(kotlin/Byte =...) // org.kotlincrypto.sponges.keccak/keccakP|keccakP@org.kotlincrypto.sponges.keccak.F800(kotlin.Byte){}[0]
final fun <#A: kotlin/Number> org.kotlincrypto.sponges.keccak/KeccakP(org.kotlincrypto.sponges.keccak/State<#A, *>, kotlin/Byte =...) // org.kotlincrypto.sponges.keccak/KeccakP|KeccakP(org.kotlincrypto.sponges.keccak.State<0:0,*>;kotlin.Byte){0ยง<kotlin.Number>}[0]
